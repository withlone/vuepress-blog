# GC

[[TOC]]

## 判断可回收

- `引用计数法`: 记录对对象的引用数, 当引用数为0时可被回收, 但循环引用会导致引用计数器补位0, java不使用该方法
- `可达性分析`: 以`GC Roots`为起点搜索, 可达对象是存活的, 不可达对象被回收

## 引用类型

- `强引用`: 不会被回收
- `软引用`: 内存不够时回收
- `弱引用`: gc发生时回收
- `虚引用`: 用于在对象被回收时收到系统通知

## 垃圾回收算法

- `标记-清除`: 标记存活, 清除未标记. 效率低, 存在内存碎片
- `标记-整理`: 存活对象重排为连续紧密的内存空间, 清除边界外内存空间
- `复制`: 内存分为两部分, 每次使用一部分, gc时将使用部分的存活对象复制到另一部分的连续内存中
- `分代`: 根据对象存活周期分代, 新生代通常用`复制`, 老年代通常用`标记-清除`或`标记-整理`

## 垃圾收集器

**串行**: 指垃圾回收和用户程序交替进行, 与**并行**相对

下图为HotSpot中主要的垃圾收集器, 连线表示可以配合使用

![gc.jpg](/java/gc.jpg)

- `Serial`: 串行, 单线程, 新生代复制
- `ParNew`: 串行, 多线程, 新生代复制
- `Parallel Scavenge`: `ParNew`的吞吐量优先版(指用户代码占CPU总时更大), 其他收集器一般垃圾回收频繁, 但停顿时间短
- `Serial Old`: `Serial`老年代版, 标记-整理
- `Parallel Old`: `Parallel Scavenge`老年代版, 标记-整理
- `CMS`: 老年代收集器, 使用标记清除
  1. 初始标记: 标记`GC Roots`能直接关联的对象, 停顿, 快速
  2. 并发标记: 标记通过`GC Roots`能达到的所有对象, 不停顿, 耗时最长
  3. 重新标记: 修正上一步进行时产生变动的对象的记录, 停顿
  4. 并发清除: 不停顿, 耗时长
  - 缺点: 吞吐量低, 并发清除清除阶段有浮动垃圾只能下一次GC处理, 收集后存在空间碎片, 容易导致提前`Full GC`
- `G1`: 对新生代和老年代均回收, 用Region的概念将内存空间划分为多个小空间,每个小空间单独GC, 使得停顿时间可预测
  1. 初始标记
  2. 并发标记
  3. 最终标记: 修正并发标记中产生变动的对象, 停顿
  4. 筛选回收: 对Region排序, 根据用户期望GC停顿时间指定回收计划

## 内存分配与回收机制

- `Minor GC/Young GC`: 仅对新生代的GC
- `Major GC/Old GC`: 仅对老年代的GC, 目前仅`CMS`
- `Mixed GC`: 收集整个新生代和部分老年代, 目前仅`G1`
- `Full GC`: 收集整个java堆和方法区
