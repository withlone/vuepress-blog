# 理论基础

[[TOC]]

## JVM整体架构

![JVM](/java/JVM.png)

## 类字节码

class文件是以8字节为单位的二进制流, java文件编译为class文件后, 可以被jvm识别以及运行

**文件结构**:

![java-jvm-class-2](/java/java-jvm-class-2.png)

## JMM(Java Memory Model)

- `线程私有`: 程序计数器, 虚拟机栈, 本地方法区
- `线程共享`: 堆, 方法区, 堆外内存(java7永久代, java8元空间)

### 程序计数器

> 线程私有的, 记录线程运行到的字节码指令地址

### 虚拟机栈

> 保存方法的局部变量, 部分结果, 方法的调用和返回

- 大小是动态或固定不变的
  - `固定不变`: 在有线程请求分配栈容量超过最大容量时, 抛出`StackOverflowError`
  - `动态`: 尝试扩展时无法申请足够内存, 或新线程无法申请足够内存, 抛出`OutOfMemoryError`
- `-Xss`设置栈空间大小
- 每个线程有自己的栈, 以栈帧格式存在, 正在运行的方法对应一个栈帧, 栈帧包含以下数据
  - `局部变量表`: 在编译器确定大小
  - `操作数栈`: 保存计算的中间结果
  - `动态链接`: 将符号引用转为调用方法的直接引用
  - `方法返回地址`: 存放调用该方法的PC值

### 本地方法栈

- 与其他语言交互
- 与操作系统交互
- 在HotSpot中本地方法栈和虚拟机栈合二为一

### 堆

- 存放对象实例, 逻辑上分为三代(分代理由为优化gc性能), 新生代, 老年代, 元空间
  - `新生代`: 新对象, 使用次数较少, 使用`Minor GC`, 分为`Eden:From Survivor:To Survivor=8:1:1`.
    1. 新对象在`Eden`创建
    2. `Minor GC`时将`Eden`和`From Survivor`中存活对象复制到`To Survivor`
    3. 清空`Eden`和`From Survivor`
    4. 交换`From Survivor`和`To Survivor`
    5. 存活一定次数后的对象移动到老年代
  - `老年代`: 使用次数较多的对象或大对象, 使用`Major GC`
- `-Xmx`设置最大堆内存(默认`电脑内存/4`)和`-Xms`设置堆起始内存(默认`电脑内存/64`), 堆大小超过`-Xmx`抛出`OutOfMemoryError`
- `Mixed GC`: 整个新生代和部分老年代的`GC`, `Full GC`: 整个java堆和方法区的`GC`
- `TLAB`(Thread Local Allocation Buffer): 对`Eden`划分, 每个线程有一个私有缓存区, 避免部分线程安全问题

#### 逃逸分析

> 分析一个对象的引用的使用范围从而决定是否将对象分配到堆上
>  
> 方法中定义且只在方法中使用不会逃逸, 方法中定义但被外部方法引用(如作为返回值)则会逃逸

1. `同步省略`: 非逃逸对象只能被一个线程访问, 则取消同步代码
2. `标量替换`: 非逃逸对象无需连续内存, 可以仅保存对象的部分字段, 存储在CPU寄存器中
3. `栈上分配`: 非逃逸对象由堆分配转为栈分配

### 方法区

> 存储类信息、常量池、静态变量、JIT编译后的代码等数据

- 永久代和元空间是方法区的具体实现, 永久代是堆的一部分, 元空间存在本地内存(堆外内存)
- 移除永久代原因(仅HotSpot中有): 永久代设置空间大小难确定, 永久代调优困难
- 垃圾回收: 常量池中废弃的常量和不再使用的类型

## 类加载机制

### 类加载过程

- `加载`: 通过类的全限定名获取二进制字节流, 将其中表示的静态结构转为方法区的运行时数据结构, 在堆中生成一个代表该类的java.lang.Class对象作为对方法区这些数据的访问入口
- `验证`: 确保被加载的类的正确性, 包括文件格式验证, 元数据验证, 字节码验证, 符号引用验证
- `准备`: 在方法区为静态变量分配内存并初始化为默认值
- `解析`: 将符号引用转为直接引用
- `初始化`: 变量初始值以及静态代码块

### 类加载器

- `启动类加载器`: JVM自身需要的类, 由C++实现
- `扩展类加载器`: Sun公司用Java实现的类, 开发者可用
- `应用程序类加载器`: 加载用户类路径所指定的类, 未自定义自己的类加载器的应用程序使用的类加载器
- `自定义类加载器`: 用户编写的类加载器

#### 类加载实现

- `Class.forName()`: 将class文件加载到JVM, 并解释类, 执行static块, 带参数的版本可控制是否执行static块
- `ClassLoader.loadClass()`: 仅将class文件加载到JVM, 不执行static块

### JVM类加载机制

- `全盘负责`: 加载某个Class时其所有依赖Class均由该类加载器加载
- `父类委托`: 让父类加载器尝试加载, 无法加载时从自己的类路径加载
- `缓存机制`: 加载过的Class被缓存, 不存在缓存区的Class才会加载并转化为Class对象存入缓存区
- `双亲委派机制`: 收到类加载请求时先委托父类加载器, 然后继续委托父类的父类加载器, 直到顶层, 当父类加载器无法加载才会让子类加载器加载
  - 优势: 防止内存出现相同的字节码, 保证java程序安全稳定运行
