# 理论基础

[[TOC]]

## 并发三要素

- 可见性: CPU缓存, 不同线程对一个变量的修改其他线程不能马上看到, 而是先修改线程自身的缓存
- 原子性: 一行代码含有的多个操作无法保证绝对连续执行, 涉及地址多次操作(如`x = y, x++`)一般不保证原子性
- 有序性: 代码经JVM优化后会发生指令重排, 进而可能导致可见性问题

## Happens-Before 规则

- 单一线程原则: 一个线程内, 程序前面操作先于后面操作
- 管程锁定规则: unlock先于对同一个锁的lock
- volatile变量规则: volatile变量的写操作先于读操作
- 线程启动规则: Thread对象的start()先于该线程所有操作
- 线程加入规则: Thread对象的结束先于join()返回
- 线程中断规则: 线程interrupt()先于中断线程代码检测到中断事件
- 对象终结规则: 对象的初始化先于finalize()的开始
- 传递性: A先于B, B先于C, 则A先于C

## 线程安全等级

1. 不可变: 一定线程安全
2. 绝对线程安全: 无论运行环境, 无需同步即可保证线程安全
3. 相对线程安全: 对对象单独操作线程安全, 调用无需额外措施, 但是需要代码持续运行需要同步保证调用正确, 如Vector获取元素线程试图访问被删除元素会抛出异常导致无法继续
4. 线程兼容: 对象本身不是线程安全, 但可以通过同步保证线程安全
5. 线程对立: 无论是否同步都无法在多线程中使用

## 线程安全的实现

- 使用锁进行互斥同步(阻塞同步)
- 非阻塞同步:
  - CAS: 对内存V操作时, 只有当V的值等于A时才会修改为B
  - AtomicInteger: 使用CAS实现操作
  - ABA: CAS存在的问题, 一个变量被读取时是A, 经过多次修改又改回了A, 导致CAS认为其未发生变化, AtomicStampedReference解决(一般不影响线程安全)
- 无同步方案:
  - 栈封闭: 线程自己的栈内变量无线程安全问题
  - 线程本地存储: 将线程共享数据的代码在同一线程中执行, 如一个Web请求对应一个服务器线程

## 线程的实现

- 实现Runnable接口, 无返回值, 不能抛出异常
- 实现Callable接口, 有返回值, 可抛出异常
- 继承Thread类

## 线程基础使用

- `Thread::setDaemon()`: 设置守护线程, 守护线程为后台进程, 所有非守护进程结束时杀死守护线程
- `Thread.yield()`: 声明线程已完成重要部分, 可让同优先级其他线程优先运行
- `Thread::interrupt()`: 外部调用为中断进程, 内部调用(仅限于继承Thread用法)为判断进程是否中断

### 线程同步互斥

- `synchronized`: 同步一个代码块/方法/类/静态方法, JVM实现, 不可等待中断, 非公平锁
- `ReentrantLock`: JDK实现, 可等待中断, 公平锁/非公平锁

---

- `wait(), notify(), notifyAll()`: Object自带
- `await(), signal(), signalAll()`: JUC实现的Condition, 在`lock()`和`unlock()`之间使用

## Java锁

- 乐观锁: 不锁住同步资源, 适合读操作多, 如CAS
- 悲观锁: 锁住同步资源, 适合写操作多, 如AtomicInteger

---

- 自旋锁: 获取同步资源失败时, 不放弃CPU时间片, 通过自旋尝试获取锁, 能减少CPU切换和恢复现场产生的损耗
- 自适应自旋锁: 根据之前自旋获取锁的成功情况调整自旋次数策略

---

- 公平锁: 线程按申请锁的顺序执行, 线程不会饿死, 但吞吐效率低
- 非公平锁: 线程直接尝试获取锁, 新线程获取锁无需唤醒旧线程, 减少唤醒线程开销, 吞吐率高, 但线程可能饿死, 如synchroinzed

---

- 可重入锁: 同一线程外层方法获取锁后进入内层方法, 内层方法自动获取锁(如锁同一个对象或class), 如ReentrantLock, synchronized
- 非可重入锁: 如NonReentrantLock

---

- 独享锁/排他锁: 锁一次只能被一个线程持有, 不能加上其他任何类型锁
- 共享锁: 可被多个线程持有, 只能读取数据不能修改

**JVM锁优化**:

- 锁消除: 编译器将检测到不存在共享数据冲突的锁消除
- 锁粗化: 反复加锁的操作粗化到整个步骤加锁
- 轻量级锁: 用于大部分锁大部分时间处于无锁竞争状态的方案
  1. 在对象头`Object Header`中一部分存储对象自身的运行时数据`Mark Word`(`HashCode`, `GC Age`, `锁标记位`, `是否为偏向锁`), 另一部分存储指向方法区对象类型数据的指针`Klass Word`
  2. 锁标记位状态包含: 00轻量级锁, 01无锁, 10重量级锁
  3. 若同步对象为01状态, 则执行当前线程时, 在当前线程栈帧中创建`Lock Record`, 存储同步对象的`Mark Word`, 并用CAS将同步对象的`Mark Word`修改为指向`Lock Record`的指针, 并将栈帧中存储`Mark Word`的状态改为00
  4. 如果CAS失败, 若`Mark Word`指向当前栈帧, 说明可以继续直接使用, 否则说明被其他线程抢占, 此时通过修改锁标记位为10将锁膨胀为重量级锁
- 偏向锁: 某一线程会更多的获取锁, 让该线程进出同步块无需CAS操作, 只需测试`Mark Word`是否存在该线程的偏向锁, 出现竞争时释放偏向锁并暂停偏向线程
