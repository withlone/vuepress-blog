# 理论基础

## 并发三要素

- 可见性: CPU缓存, 不同线程对一个变量的修改其他线程不能马上看到, 而是先修改线程自身的缓存
- 原子性: 一行代码含有的多个操作无法保证绝对连续执行, 涉及地址多次操作(如`x = y, x++`)一般不保证原子性
- 有序性: 代码经JVM优化后会发生指令重排, 进而可能导致可见性问题

## Happens-Before 规则

- 单一线程原则: 一个线程内, 程序前面操作先于后面操作
- 管程锁定规则: unlock先于对同一个锁的lock
- volatile变量规则: volatile变量的写操作先于读操作
- 线程启动规则: Thread对象的start()先于该线程所有操作
- 线程加入规则: Thread对象的结束先于join()返回
- 线程中断规则: 线程interrupt()先于中断线程代码检测到中断事件
- 对象终结规则: 对象的初始化先于finalize()的开始
- 传递性: A先于B, B先于C, 则A先于C

## 线程安全等级

1. 不可变: 一定线程安全
2. 绝对线程安全: 无论运行环境, 无需同步即可保证线程安全
3. 相对线程安全: 对对象单独操作线程安全, 调用无需额外措施, 但是需要代码持续运行需要同步保证调用正确, 如Vector获取元素线程试图访问被删除元素会抛出异常导致无法继续
4. 线程兼容: 对象本身不是线程安全, 但可以通过同步保证线程安全
5. 线程对立: 无论是否同步都无法在多线程中使用

## 线程安全的实现

- 使用锁进行互斥同步(阻塞同步)
- 非阻塞同步:
  - CAS: 对内存V操作时, 只有当V的值等于A时才会修改为B
  - AtomicInteger: 使用CAS实现操作
  - ABA: CAS存在的问题, 一个变量被读取时是A, 经过多次修改又改回了A, 导致CAS认为其未发生变化, AtomicStampedReference解决(一般不影响线程安全)
- 无同步方案:
  - 栈封闭: 线程自己的栈内变量无线程安全问题
  - 线程本地存储: 将线程共享数据的代码在同一线程中执行, 如一个Web请求对应一个服务器线程

## 线程的实现

- 实现Runnable接口
- 实现Callable接口
- 继承Thread类

## 线程基础使用

- `Thread::setDaemon()`: 设置守护线程, 守护线程为后台进程, 所有非守护进程结束时杀死守护线程
- `Thread.yield()`: 声明线程已完成重要部分, 可让同优先级其他线程优先运行
- `Thread::interrupt()`: 外部调用为中断进程, 内部调用(仅限于继承Thread用法)为判断进程是否中断

### 线程同步互斥

- `synchronized`: 同步一个代码块/方法/类/静态方法, JVM实现, 不可等待中断, 非公平锁
- `ReentrantLock`: JDK实现, 可等待中断, 公平锁/非公平锁

---

- `wait(), notify(), notifyAll()`: Object自带
- `await(), signal(), signalAll()`: JUC实现的Condition, 在`lock()`和`unlock()`之间使用

## Java锁

- 乐观锁: 不锁住同步资源, 适合读操作多, 如CAS
- 悲观锁: 锁住同步资源, 适合写操作多, 如AtomicInteger

---

- 自旋锁: 获取同步资源失败时, 不放弃CPU时间片, 通过自旋尝试获取锁, 能减少CPU切换和恢复现场产生的损耗
- 自适应自旋锁: 根据之前自旋获取锁的成功情况调整自旋次数策略

---

- 

- 锁消除: 编译器将检测到不存在共享数据冲突的锁消除
- 锁粗化: 反复加锁的操作粗化到整个步骤加锁